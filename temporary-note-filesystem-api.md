## `fs.writeFile()`

CALLBACK API

`fs.writeFile()`は非同期関数です。

```TypeScrpt
// 省略

```

引数：

`file`がファイル名だったなら、非同期的にデータをファイルへ書き込みます。
既存ファイルであった場合、ファイルを置き換えます。

`data`はstring型かBuffer型である必要があります。

`file`がファイル記述子だった場合、
`fs.write()`（こっちが推奨）を直接呼び出すのと似たことになります

--> ファイル記述子をわたすなら`fs.write()`を使おう

`encoding`オプションは、`file`が`Buffer`型だった場合に無視されます。

`mode`オプションは新規ファイル作成するときにだけ有効になります。

`data`が通常オブジェクトの場合、そのオブジェクトは`toString`関数を所持していなくてはなりません。

使い分けについて：

同一のファイルに対して、コールバックが戻る前に何度も`fs.writeFile()`を呼び出してはなりません。
そのような扱いが必要なときは、`fs.createWriteStream()`の使用が推奨されます。

fs.readFile と同様 - fs.writeFile は、渡されたバッファを書き込むために内部で複数の`write`呼び出しを実行する便利なメソッドです。

パフォーマンスが重要なコードについては、fs.createWriteStream() の使用を検討してください。

<AbortSignal> を使用して fs.writeFile() をキャンセルすることができます。
キャンセルは「最大限の努力」であり、ある程度の量のデータがまだ書き込まれている可能性があります。

進行中のリクエストを中止しても、個々のオペレーティング システム リクエストは中止されませんが、内部バッファリング fs.writeFile が実行されます。

--> つまり、キャンセルできるようでいて、その実キャンセル完了は確約できないということだと思われ。

ファイル記述子に関して：

割愛


解釈：

https://stackoverflow.com/questions/8769071/difference-between-fs-writefile-and-fs-writestream

**パフォーマンスがいいメソッドではない**

RAMにあるデータをファイルへ書き込む関数である。

なので大きなサイズのファイルを扱うと最低なパフォーマンスになる。

ただし書き込み処理を一手にお任せできる便利さがあるメソッドなようである。

内部的には、`write`呼び出し(カーネルのコールのことだと思う）を、

この関数に渡されたバッファデータに対して呼び出している。

Cでいうところの、open()とwrite()を一手に担っているのである。

`fs.write`はあらかじめ開かれているファイルが必要で、より低レベルの関数であり、`fs.writeFile`はより高レベルな関数である。

使いどころとしては非常に小さなファイルの書き込みを行いたいときだけにすべき。


streamを使う場合との違いが、

このようにファイルデータがメモリに展開されてから書き込まれるという点であるのだろう。

streamは読み取り先が開かれていればstreamをつなげればメモリ消費少なく読み取り・書き込みができるのでパフォーマンスに優れる。

...のだと思う。

この辺、Linuxの本を読み返せばさらに理解が深まるかも...

## `fs.write()` buffer as parameter

以下含め割愛。

`fs.write()` string as parameter
`fs.writev()`

## `fs.WriteStream`

https://nodejs.org/dist/latest-v16.x/docs/api/fs.html#class-fswritestream

`fs.createWriteStream()`によって生成されるインスタンスのクラス

`stream.Writable`を基底クラスとしている。

fs.d.tsを見たところ、いくつかのイベントリスナとメソッドを持つ。

