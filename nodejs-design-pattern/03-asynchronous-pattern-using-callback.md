# 3章 コールバックを用いた非同期パターン


コールバックをうまく使いこなして、保守が容易なコードを書くための、いくつかの原則とパターンを学ぶ。

クロージャを多用することは望ましくない。理由はアプリケーションが大規模化するにしたがって関数呼び出しのレベルが深くなって、コードの制御フローの追跡が困難になるからである。

## 自習：JavaScriptのメモリリークについて

https://qiita.com/tkdn/items/ea4f034e0d661def244a#3-%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3

> JavaScript開発者もメモリリークについて考えなくてはならない。

> 高水準言語を扱っているときも開発者はメモリ管理について理解をするべきである。

> 自動的なメモリ管理については問題が生じる場合もあるのです。

> ガベージコレクタは、不要となったメモリの一部を見つけて自動的にそのメモリを解放するために、メモリの割り当ていちと使用を追跡する。

> ただし残念なことに、このプロセスは「近似」なのです。なぜなら、メモリのある一部が必要であるか知るという一般的な問題は決めることが不可能だからです。

つまりアルゴリズムじゃそれが不要なメモリだ！と判定できないというわけですね。

> ガベージコレクションのアルゴリズムにおける主なコンセプトは**参照**の一部に依存しています。

主なアルゴリズムは以下の2つ。`参照がゼロになったらGC`、`mark&sweep`。

> これは一番シンプルなガベージコレクションのアルゴリズムです。あるオブジェクトへの参照がゼロになったら、このオブジェクトは "ガベージコレクト可能だ" と判断するのです。

そいつは誰かから参照されているか？

> アルゴリズムはすべてのルートとその子オブジェクトを辿り調査し、アクティブ（つまりガベージではないということ）なものとしてマークしていきます。ルートから到達できないものはすべてガベージとしてマークされるでしょう。

そいつには到達可能か？

循環参照は`参照がゼロになったらGC`だと参照されているから永遠にGCできないけど、`mark&sweep`なら両者が到達できないならGCできる。

C++の話みたいになってきたCOMでも使えばいいかしら。

#### 4種類の一般的なJavaScript共通のメモリリーク

- 予期しないグローバル変数

定義されていない変数が参照されるとそれはグローバルオブジェクトに追加されてしまう。

これは関数のthisがグローバル変数を指しているから起こることと関係があるようで、

`use strict`で防止できる。

関数が内部でグローバル変数を参照すると、関数は存在する変数を参照しているままになるのでその関数は用が済んでもGCされない。

なのでどうしてもグローバル変数にアクセスしたいときは、関数内部でグローバル変数にアクセスする変数をnullにすること。

```JavaScript
var theThing = null;    // グローバル変数
var replaceThing = function () {

  var originalThing = theThing; // originalThingはグローバル変数の参照を持ち...
  var unused = function () {
    if (originalThing) // クロージャでグローバル変数の参照を持ってしまった
      console.log("hi");
  };

  theThing = {
    longStr: new Array(1000000).join('*'),
    someMethod: function () {
      console.log("message");
    }
  };
  originalThing = null  // nullで参照をなくす
};
```
TODO: 他の３つもまとめておくこと