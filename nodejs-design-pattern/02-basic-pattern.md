# Node.js 基本のパターン

『Node.js デザインパターン 第2版』（オライリージャパン）第2章のノートである。

Nodeの非同期プログラミングの土台となる3つのパターン、

すなわちコールバック、モジュール、EventEmitter(Observerパターン)について学習する。

## コールバック・パターン

#### コールバックの種類

- 同期的継続渡しスタイル(同期CPS)

- 非同期的継続渡しスタイル(非同期CPS)

継続渡しスタイルとは、return文を返す代わりに引数として受け取った関数（コールバック関数）を続けて実行するような処理をすることである。

一方でreturn文を返し処理を呼び出し側に戻すのはダイレクトスタイルという。

CPSの特徴：

同期的CPSはコールバック関数の処理が完了するまで呼び出し側は待つことになる。

非同期CPSはコールバック関数が非同期的に実行されるのでコールバック関数が完了するのを待たずに呼び出し側に戻る。



#### 同期処理と非同期処理が混在する関数を作ってはならない


「一貫性のないAPI」だと発見困難なバグの原因になる

たとえば、

上記の同期CPSと非同期CPSが混在した関数が存在し、条件によってどちらかの処理をすることになるとする。

呼び出し側は非同期関数と思って使ってみると同期処理になって処理完了までものすごい時間待たされた

...なんてことが起こりうる。

同期処理と非同期処理が混在せず同期処理のみはたまた非同期処理のみで実装された関数

同期処理と非同期処理が混在するような関数は非常に発見が困難なバグの温床になる

Node.jsでは同期的継続渡し、非同期的継続渡し、PromiseAPIなど同じ処理をするけど別バージョンである関数がたくさんあるので、

それらを混在させないように気を付けよう。

#### 同期処理と非同期処理が混在する関数の解決策

1. 同期APIの利用

同期的なAPIは常にダイレクトスタイルで実装したほうが単純でわかりやすい

例えばコールバックAPIの`fs.readaFile()`の代わりに`fs.readFileSync()`を使うといい。

呼び出し側もDSへ書き直す場合もあるので注意。

2. 遅延実行

混在関数を完全に非同期関数にしてしまう。

同期的なコールバックは`process.nextTick()`を使うと将来起動するようにスケジュールできる。


#### コールバックに関数慣習

従うべきお作法でございます。

1. callbaskを引数で渡すときは必ず引数リストの一番最後の引数とすること

> 関数のコールバックを指定する場合には必ず最後の引数とします。これはNodeのコアメソッドすべてに当てはまります。

2. エラーオブジェクトは第一引数として取得し、必ずエラーチェック

継続渡しスタイルではエラーはコールバック関数に渡される。

エラーオブジェクトは必ずコールバック関数の第一引数で取得する。

そして必ずコールバックではエラーオブジェクトを取得していないかチェックしよう

3. ダイレクトスタイルにおけるエラー検知はtry...catchで

もしもtry...catchで囲わなかったら、

例外がコールバック関数内で発生すると、イベントループまで伝番し、

どこにもキャッチされない。

つまりえラーが発生しない。

イベントループまでエラーが伝番したらアプリケーションが停止するらしい。

それ自体はイベントリスナを設定できる。

`process.on('uncaughtException', ()=> {})`


## モジュールシステムとパターン

JavaScriptには`namespace`が存在しないから名前衝突が容易に起こってしまう。

これは回避する方法が、JavaScriptの関数はプライベートなスコープを生成するという特性を利用した、

モジュールパターンである。

Nodejsのモジュールシステムは、

如何に依存関係を解決しロードするのかという役割と、

モジュールAPIのカプセル化をするという役割があり

それぞれの特徴やパターンを学ぶ。

#### 依存解決順序

複数のソフトウェアが同一モジュールだけど異なるバージョンに依存している状態は依存地獄と呼ばれ忌避される。

Nodeではこの問題を解決する機能が備わっており、次のような3段階のアルゴリズムで解決される。

1. Nodeのコアモジュールか？
2. `/`や`./`や`../`などのパスを指定しているか
3. それ以外の場合

たとえば

```JavaScript
const fs = require('fs');   // Node.jsのFile Systemモジュール
const utils = require('../utils/index.js'); // ファイルモジュール
const axios = require('axios');  // パッケージモジュール
```

1 --> 2 --> 3の順番で解決される。

1や2に関してはおなじみだと思う。

3に関して:

1や2でもないなら、まずnode_modules/以下に該当のパッケージがないか捜索する。

なかったら親ディレクトリを探し始める。

そこでもなかったらさらに上へ上へと探し回る。

最終的にローカルファイルシステムのルートディレクトリに到達するまで探し回る。

こうして見つかったパッケージモジュールから、

さらにロードすべきファイルに関して次のルールに従う。

- 同一ファイル名があればそのファイルをロードする。
- 同一名ディレクトリのpackage.jsonのmainプロパティに記されたファイルをロードする。
- 同一名ディレクトリの配下にindex.jsがあればそれをロードする。

...以上のアルゴリズムをrequire()が内部的に実行することで依存関係が解決できるらしい。

#### キャッシュのもたらすメリットデメリット

毎回require()が呼ばれるたびに律儀にアルゴリズムに従って導き出したファイルからロードはしない。

一度呼び出されたらnpm cacheへ保存され次回以降の呼び出しはそこから行われる。

キャッシュによって循環参照が可能となってしまう。

TODO: 循環参照について調べる。

